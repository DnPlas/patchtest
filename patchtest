#!/usr/bin/env python

import sys
import os
import unittest
import argparse
import fileinput
import json

# Include current path so test cases can see it
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))

# Include patchtest library
sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lib'))

from repo import Repo, PatchException
from summary import BasicSummary
import utils

# When parsing the arguments, the following class (PatchTestArgs)
# would be used as target namespace. This is a simple approach to
# pass arguments to the test case.
class PatchTestArgs:
    pass
 
def get_result(args):

    class Result(unittest.TextTestResult):
        """ Formats the summary and post result at the end """

        shouldStop = True

        def startTestRun(self):
            self.repo = Repo(args.commit, args.branch, args.mbox, args.series, args.revision, args.repodir, args.tempbasedir)
            self.summary = BasicSummary(args.series, args.revision, self.repo.mboxurl, self.repo.tempdir)
            self.success = True

            try:
                self.repo.setup()
            except PatchException as pe:
                self.repo.clean(keepbranch=False)

        def addError(self, test, err):
            if self.success:
                self.success = False

            (ty, va, trace) = err
            import traceback
            traceback.print_tb(trace)
            self.stop()

        def addFailure(self, test, err):
            if self.success:
                self.success = False
            self.summary.addFailure(test, err)

        def addSuccess(self, test):
            self.summary.addSuccess(test)

        def stopTestRun(self):
            state = 'success' if self.success else 'failure'
            summary = self.summary.generateSummary()

            print summary

            if not args.nopost:
                self.repo.post(args.testname, state, summary)

            self.repo.clean(keepbranch=args.keepbranch)

        @classmethod
        def stop(cls):
            pass

    return Result

def get_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument('--series', '-s',
                        dest='series',
                        help='Series number')

    parser.add_argument('--revision', '-r',
                        dest='revision',
                        help='Revision number')

    parser.add_argument('--no-post',
                        dest='nopost',
                        action='store_true',
                        help="Do not POST the results to the PW instance")

    parser.add_argument('--mbox', '-m',
                        dest='mbox',
                        help='An mbox file, to apply before testing')

    parser.add_argument('-C',
                        dest='repodir',
                        default=os.getcwd(),
                        help="Name of the repository where mboxs are applied")

    parser.add_argument('--temp-base-dir',
                        dest='tempbasedir',
                        default='/tmp/patchtest',
                        help="Name of the directory where logs are created")

    parser.add_argument('--test-name',
                        dest='testname',
                        default='patchtest',
                        help="Test name to be used if results are POSTed")

    parser.add_argument('--keep-branch',
                        dest='keepbranch',
                        action='store_true',
                        help="Do not POST the results to the PW instance")

    patchtest_tests_dir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)),
        'tests')
    parser.add_argument('--test-dir',
                        dest='testdir',
                        default=patchtest_tests_dir,
                        help="Directory where tests are located")

    parser.add_argument('--branch', '-b',
                        dest='branch',
                        default='master',
                        help="Branch to work on, default is master. Must be available in repo")

    parser.add_argument('--commit', '-c',
                        dest='commit',
                        default='HEAD',
                        help="Commit to work on, default is HEAD. Must be visible from branch")

    return parser

def main():
    get_parser().parse_args(namespace=PatchTestArgs)

    listseries = []
    listmbox = []

    # read the stdin if series/revision are passed this way
    if not sys.stdin.isatty():
        print 'Info: using stdin, ignoring parameters'
        for line in fileinput.input('-'):
            try:
                event = json.loads(line)
                series = event['series']
                parameters = event['parameters']
                revision = 1
                if parameters:
                    revision = parameters['revision']
                listseries.append((series, revision))
            except ValueError:
                listmbox.append(line)
        if listmbox and listseries:
            print 'Warning: received both mbox and series/revision'

    elif PatchTestArgs.mbox:
        if (PatchTestArgs.series or PatchTestArgs.revision or PatchTestArgs.nopost):
            print 'patchwork-related parameters (--series, --revision, --no-post) cannot be used with --mbox'
            return 1
        listmbox = [PatchTestArgs.mbox]

    else:
        if not (PatchTestArgs.series and PatchTestArgs.revision):
            print 'you need to specify the series/revision through --series and --revision, respectively\nor alternatively, specify the mbox through --mbox'
            return 1
        listseries = [(PatchTestArgs.series, PatchTestArgs.revision)]

    for series, revision in listseries:

        PatchTestArgs.series = series
        PatchTestArgs.revision = revision
        run()

    for mbox in listmbox:

        PatchTestArgs.mbox = mbox
        run()

    return 0

def run():
    """ Load, setup and run tests, this is run for each item in listseries and/or listmbox"""
    loader = unittest.TestLoader()
    suite = loader.discover(os.path.abspath(PatchTestArgs.testdir))

    # Get the result class and install the control-c handler
    resultklass = get_result(PatchTestArgs)
    unittest.installHandler()
    unittest.registerResult(resultklass)

    runner = unittest.TextTestRunner(resultclass=resultklass)
    result = runner.run(suite)

if __name__ == '__main__':
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc(5)
    sys.exit(ret)
