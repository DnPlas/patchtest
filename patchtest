#!/usr/bin/env python

import sys
import os
import unittest
import argparse
import fileinput
import json

# Include current path and lib
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))
sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lib'))

from base import PatchTestBase
from repo import Repo, PatchException
from summary import BasicSummary
import utils


def get_result(args):

    class Result(unittest.TextTestResult):
        """ Formats the summary and post result at the end """

        shouldStop = True

        def startTestRun(self):
            self.repo = Repo(args.series, args.revision,
                        args.repodir, args.tempbasedir)
            self.summary = BasicSummary(args.series, args.revision,
                                        self.repo.mboxurl, self.repo.tempdir)
            self.success = True

        def addError(self, test, err):
            if self.success:
                self.success = False
            # if mbox cannot be applied, just stop all testing
            if isinstance(err[1], PatchException):
                self.summary.patchFailure(err)
                self.stop()
            else:
                # TODO: something really wrong went here, we should indicate
                # patchwork to send the log to the mantainer, not the submitter
                self.summary.addError(test, err)

        def addFailure(self, test, err):
            if self.success:
                self.success = False
            self.summary.addFailure(test, err)

        def addSuccess(self, test):
            self.summary.addSuccess(test)

        def stopTestRun(self):
            state = 'success' if self.success else 'failure'
            summary = self.summary.generateSummary()

            print summary

            if not args.nopost:
                self.repo.post(args.testname, state, summary)

        @classmethod
        def stop(cls):
            pass

    return Result

def get_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument('--series', '-s',
                        dest='series',
                        help='Series number')

    parser.add_argument('--revision', '-r',
                        dest='revision',
                        help='Revision number')

    parser.add_argument('--no-post',
                        dest='nopost',
                        action='store_true',
                        help="Do not POST the results to the PW instance")

    parser.add_argument('--mbox', '-m',
                        dest='mbox',
                        help='An mbox file, to apply before testing')

    parser.add_argument('-C',
                        dest='repodir',
                        default=os.getcwd(),
                        help="Name of the repository where mboxs are applied")

    parser.add_argument('--temp-base-dir',
                        dest='tempbasedir',
                        default='/tmp/patchtest',
                        help="Name of the directory where logs are created")

    parser.add_argument('--test-name',
                        dest='testname',
                        default='patchtest',
                        help="Test name to be used if results are POSTed")

    patchtest_tests_dir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)),
        'tests')
    parser.add_argument('--test-dir',
                        dest='testdir',
                        default=patchtest_tests_dir,
                        help="Directory where tests are located")

    parser.add_argument('--branch', '-b',
                        dest='branch',
                        default='master',
                        help="Branch to work on, default is master. Must be available in repo")

    parser.add_argument('--commit', '-c',
                        dest='commit',
                        default='HEAD',
                        help="Commit to work on, default is HEAD. Must be visible from branch")

    return parser

def main():
    # parse the arguments and set PatchTestBase as target namespace.
    # this is a simple approach to pass arguments to the test case.
    # If series/revisions are coming from stdin, then these are
    # manually updated for each one. We need to find a better way
    # to do this
    get_parser().parse_args(namespace=PatchTestBase)

    listseries = []
    listmbox = []

    # read the stdin if series/revision are passed this way
    if not sys.stdin.isatty():
        print 'Info: using stdin, ignoring parameters'
        for line in fileinput.input('-'):
            try:
                event = json.loads(line)
                series = event['series']
                parameters = event['parameters']
                revision = 1
                if parameters:
                    revision = parameters['revision']
                listseries.append((series, revision))
            except ValueError:
                listmbox.append(line)
        if listmbox and listseries:
            print 'Warning: received both mbox and series/revision'

    elif PatchTestBase.mbox:
        if (PatchTestBase.series or PatchTestBase.revision or PatchTestBase.nopost):
            print 'patchwork-related parameters (--series, --revision, --no-post) cannot be used with --mbox'
            return 1
        listmbox = [PatchTestBase.mbox]

    else:
        if not (PatchTestBase.series and PatchTestBase.revision):
            print 'you need to specify the series/revision through --series and --revision, respectively\nor alternatively, specify the mbox through --mbox'
            return 1
        listseries = [(PatchTestBase.series, PatchTestBase.revision)]

    for series, revision in listseries:

        PatchTestBase.series = series
        PatchTestBase.revision = revision
        run()

    for mbox in listmbox:

        PatchTestBase.mbox = mbox
        run()

    return 0

def run():
    """ Load, setup and run tests, this is run for each item in listseries and/or listmbox"""
    loader = unittest.TestLoader()
    suite = loader.discover(os.path.abspath(PatchTestBase.testdir))

    # Get the result class and install the control-c handler
    resultklass = get_result(PatchTestBase)
    unittest.installHandler()
    unittest.registerResult(resultklass)

    runner = unittest.TextTestRunner(resultclass=resultklass)
    result = runner.run(suite)

if __name__ == '__main__':
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc(5)
    sys.exit(ret)
