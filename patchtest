#!/usr/bin/env python

import sys
import os
import unittest
import fileinput
import json
import logging

# Include current path so test cases can see it
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))

# Include patchtest library
sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lib'))

from patchtestargs import PatchTestArgs

import utils
logger = utils.logger_create('patchtest')

import repo
from summary import BasicSummary

def getResult(series, revision, mbox):

    class PatchTestResult(unittest.TextTestResult):
        """ Formats the summary and post result at the end """

        shouldStop = True
        longMessage = True

        def startTestRun(self):
            repoargs = {
                'repodir':PatchTestArgs.repodir,
                'commit':PatchTestArgs.commit,
                'branch':PatchTestArgs.branch,
                'mbox':mbox,
                'series':series,
                'revision':revision,
            }
            self.repo = repo.Repo(**repoargs)
            self.summary = BasicSummary(self.repo.items)

            # these variables turn to True if either pathing or any test failed
            # in these case, the test's status would be 'failure'
            self.patch_error = False
            self.test_failure = False

            # these variables turn to True on any exception (RepoException, CmdException and any other
            # exception coming from the tests)
            self.repo_error = False
            self.cmd_error = False
            self.test_error = False

            try:
                self.repo.setup(PatchTestArgs.nopatch, PatchTestArgs.forcepatch, PatchTestArgs.storembox)
            except repo.PatchException as pe:
                self.patch_error = True
                self.summary.addPatchFailure(str(pe))
                self.stop()
            except repo.RepoException as re:
                self.repo_error = True
                logger.error(rp)
                self.stop()
            except utils.CmdException as ce:
                self.cmd_error = True
                logger.error("Command failed: %s %s %s" % (ce.cmd, ce.stdout, ce.stderr))
                self.stop()

        def addError(self, test, err):
            self.test_error = True
            (ty, va, trace) = err
            import traceback
            traceback.print_tb(trace)
            self.stop()

        def addFailure(self, test, err):
            self.test_failure = True
            self.summary.addFailure(test, err)

        def addSuccess(self, test):
            self.summary.addSuccess(test)

        def addSkip(self, test, msg):
            self.summary.addSkip(test, msg)

        def stopTestRun(self):
            # leave the working directory as it was, and remove branch if desired
            self.repo.clean(PatchTestArgs.nopatch, PatchTestArgs.keepbranch)

            # just post when there are no repository, commands and test exceptions
            if not (self.repo_error or self.cmd_error or self.test_error):
                # generate the summary
                summary = self.summary.generateSummary()
                logger.info("%s" % summary)

                # set the test status
                state = None
                if self.patch_error or self.test_failure:
                    state = 'failure'
                else:
                    state = 'success'

                # POST just if --post argument is present
                if PatchTestArgs.post:
                    self.repo.post(PatchTestArgs.testname, state, summary)

    return PatchTestResult

def main():
    # Parse the command line arguments and store it on the PatchTestArgs namespace
    PatchTestArgs.set_namespace()

    if PatchTestArgs.debug:
        logger.setLevel(logging.DEBUG)
        print logger.getEffectiveLevel()
    elif PatchTestArgs.quiet:
        logger.setLevel(logging.ERROR)

    # these variables contains either items from stdin or command line arguments
    listmbox = []
    listseries = []
    listrevision = []

    # read the stdin if mbox/series/revision are passed this way
    if not sys.stdin.isatty():
        for line in fileinput.input('-'):
            try:
                event = json.loads(line)
                series = event['series']
                parameters = event['parameters']
                revision = None
                if parameters:
                    revision = parameters['revision']
                listseries.append(series)
                listrevision.append(revision)
            except ValueError:
                # we try the input as a mbox path
                listmbox.append(line.strip())
    else:
        listseries = list(PatchTestArgs.series)
        listrevision = list(PatchTestArgs.revision)
        listmbox = list(PatchTestArgs.mbox)

    if PatchTestArgs.singlebranch:
        # run tests on top of all input patches (mbox or series)
        run(listseries, listrevision, listmbox)
    else:
        # run tests for each input patch (mbox or series)
        if listseries:
            # check if lengths match, if not pad revisions with None
            difflength = len(listseries) - len(listrevision)
            listrevision.extend([None] * difflength)

            for series, revision in zip(listseries, listrevision):
                run(series=[series], revision=[revision])
        elif listmbox:
            for mbox in listmbox:
                run(mbox=[mbox])
        else:
            # no input given, just run
            run()

    return 0

def run(series=[], revision=[], mbox=[]):
    """ Load, setup and run tests """
    loader = unittest.TestLoader()
    suite = loader.discover(os.path.abspath(PatchTestArgs.testdir))

    # Get the result class and install the control-c handler
    unittest.installHandler()
    resultklass = getResult(series, revision, mbox)
    unittest.registerResult(resultklass)

    runner = unittest.TextTestRunner(resultclass=resultklass)
    result = runner.run(suite)

if __name__ == '__main__':
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc(5)
    sys.exit(ret)
