#!/usr/bin/env python

import sys
import os
import unittest
import fileinput
import logging
import traceback
import re

# Include current path so test cases can see it
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))

# Include patchtest library
sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lib'))

from patchtestdata import PatchTestInput as pti

import utils
logger = utils.logger_create('patchtest')
info = logger.info
error = logger.error

import repo
import summary

def getResult(series, revision, mbox, nopatch, post_submitters, print_values):

    class PatchTestResult(unittest.TextTestResult):
        """ Formats the summary and post result at the end """

        PATCHWORK_RESULT_FAILURE = 'failure'
        PATCHWORK_RESULT_SUCCESS = 'success'
        PATCHWORK_RESULT_PENDING = 'pending'
        PATCHWORK_RESULT_WARNING = 'warning'

        shouldStop = True
        longMessage = True

        def startTestRun(self):
            # let's create the repo already, it can be used later on
            repoargs = {
                'repodir': pti.repodir,
                'commit': pti.commit,
                'branch': pti.branch,
                'mbox': mbox,
                'series': series,
                'revision': revision,
            }

            # Indicates if repo instance was created succesfully.
            # If True, no tests are executed
            self.repo_error    = False

            # Indicates if test cases raise exception.
            # If True, trace is shown, pending tests are executed but No POST is done
            self.test_error    = False

            # Indicates if all items failed the merging phase
            # If True, no tests are done
            self.merge_failure = False

            # Indicates failures on tests
            self.test_failure  = False

            try:
                self.repo = pti.repo = repo.Repo(**repoargs)
            except:
                logger.error(traceback.print_exc())
                self.repo_error = True

            if self.repo_error:
                self.stop()
                return

            self.summary = summary.TabulateSummary(self.repo.project,
                                                   self.repo.mailinglist,
                                                   self.repo.branch,
                                                   self.repo.commit)

            # merge items
            if not nopatch:
                try:
                    self.repo.merge()
                    # if no items were merged, then stop
                    if self.repo.items and (not self.repo.any_merge()):
                        self.merge_failure = True
                        self.stop()
                except:
                    self.error = True
                    self.stop()

        def addError(self, test, err):
            self.test_error = True
            (ty, va, trace) = err
            logger.error(traceback.print_exc())

        def addFailure(self, test, err):
            self.test_failure = True
            self.summary.addFailure(test)
            if print_values:
                (_, value, _) = err
                error(value)
            else:
                error(test.id())

        def addSuccess(self, test):
            self.summary.addSuccess(test)

        def addSkip(self, test, msg):
            self.summary.addSkip(test)

        def stopTestRun(self):

            if self.repo_error:
                return

            summary = self.summary.generate(self.repo.items, self.merge_failure)
            logger.info(summary)

            state = None
            if self.test_failure or self.merge_failure:
                state = PatchTestResult.PATCHWORK_RESULT_FAILURE
            else:
                state = PatchTestResult.PATCHWORK_RESULT_SUCCESS

            if not self.test_error:
                if post_submitters:
                    # Check submitter regex (post_users) to check if system
                    # can post
                    for item in self.repo.items:
                        if item.submitter:
                            if re.search(post_submitters, item.submitter):
                                self.repo.post(pti.testname, state, summary)
                                break

            if not nopatch:
                self.repo.clean(pti.keepbranch)

    return PatchTestResult

def main():
    # read the stdin if mbox/series/revision are passed this way
    if not sys.stdin.isatty():
        pti.namespace_stdin(fileinput.input('-'))

    # these variables contain either items from stdin or command line arguments
    listseries = list(pti.series)
    listrevision = list(pti.revision)
    listmbox = list(pti.mbox)

    if pti.multiple:
        # run tests on top of all input patches (mbox or series)
        run(listseries, listrevision, listmbox)
    else:
        # run tests for each input patch (mbox or series)
        if listseries:
            # check if lengths match, if not pad revisions with None
            difflength = len(listseries) - len(listrevision)
            listrevision.extend([None] * difflength)

            for series, revision in zip(listseries, listrevision):
                run(series=[series], revision=[revision])
        elif listmbox:
            for mbox in listmbox:
                run(mbox=[mbox])
        else:
            # no input given, just run
            run()

    return 0

def _runner(resultklass, prefix=None):
    # load test with the corresponding prefix
    loader = unittest.TestLoader()
    if prefix:
        loader.testMethodPrefix = prefix

    # create the suite with discovered tests and the corresponding runner
    suite = loader.discover(os.path.abspath(pti.testdir))
    ntc = suite.countTestCases()

    # if there are no test cases, just quit
    if not ntc:
        logger.warn('No test cases found with prefix "%s", quitting' % loader.testMethodPrefix)
        return

    logger.info('Executing %s tests with prefix "%s"' % (ntc, loader.testMethodPrefix))
    runner = unittest.TextTestRunner(resultclass=resultklass)

    try:
        result = runner.run(suite)
    except:
        logger.error(traceback.print_exc())
        logger.error('patchtest failed, removing patchtest branch')
        if repo:
            pti.repo.clean(False)

def run(series=[], revision=[], mbox=[]):
    """ Load, setup and run pre and post-merge tests """
    # Get the result class and install the control-c handler
    unittest.installHandler()

    # run pre-merge tests. Pre-merge tests are those to be executed previous merging
    premerge_resultklass = getResult(series, revision, mbox, nopatch=True, post_submitters=None, print_values=pti.print_values)
    _runner(premerge_resultklass, 'pretest')

    # run standard tests
    postmerge_resultklass = getResult(series, revision, mbox, pti.nopatch, pti.post_submitters, print_values=pti.print_values)
    _runner(postmerge_resultklass)

if __name__ == '__main__':
    ret = 1

    # Parse the command line arguments and store it on the PatchTestInput namespace
    pti.set_namespace()

    # create a .patchtest folder inside the repository, a place for patchtest logging and locking
    patchtestfolder = os.path.join(pti.repodir, '.patchtest')
    if not os.path.exists(patchtestfolder):
        os.mkdir(patchtestfolder)

    # Make sure only one patchtest instance is running under a repository
    lockfile = os.path.join(patchtestfolder, 'patchtest.lock')
    if os.path.exists(lockfile):
        logger.error('patchtest locked (currently running?). Remove %s in case no patchtest is running' % lockfile)
        sys.exit(ret)
    else:
        os.mknod(lockfile)

    # enable a file handle for logging
    logfile = os.path.join(patchtestfolder, 'patchtest.log')
    logger.addHandler(logging.FileHandler(logfile))

    # set debugging level
    if pti.debug:
        logger.setLevel(logging.DEBUG)
        print logger.getEffectiveLevel()
    elif pti.quiet:
        logger.setLevel(logging.ERROR)

    try:
        ret = main()
    except Exception:
        import traceback
        traceback.print_exc(5)
    finally:
        try:
            os.remove(lockfile)
        except:
            logger.error('Patchtest lock file %s could not be removed')

    sys.exit(ret)
