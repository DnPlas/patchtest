#!/bin/bash -eu
# ex:ts=4:sw=4:sts=4:et
# -*- tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
#
# patchtest-test-mboxes: (patch) Test the provided mboxes and if required,
#                        assemble those that can be merged into a branch
#                        with results as git-notes
#
# Copyright (C) 2016 Intel Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# default values
verbose=''
repodir=''
startdir=''
assemblebranch=''
startpoint='HEAD'
outrepodir=''
mergeall=''

function usage() {
    cat << EOF
\$ $(basename $0) -r <repodir> -s <startdir> [-a <assemble branch> [-A]] [-p <start point>] [-o <outrepodir>] [-v] (mboxdir | <patch>) ...

where

    <repodir>         : Repository
    <startdir>        : Start directory for test discovery
    <assemble branch> : Branch name to assemble patches (that can be merged), including results as git-notes
    <start point>     : Start point for assemble branch. Defaults to $startpoint
    -A                : Merge the mboxes on <assemble branch> no matter if some tests have failed. By default merge is only
                        on mboxes that have passed all tests (skips are not considered)
    <outrepodir>      : Output git repository for patchtest results, created if it does not exist. Defaults to $outrepodir
    <mboxdir>         : Directory containing mboxes
    <patch>           : Patch to test by patchtest.
EOF
>&2

    exit 1
}

function gitnotes() {
    git notes --ref=patchtest-results-failures add -m  "$(echo "$PTRESULTS" | grep FAIL)" HEAD
    git notes --ref=patchtest-results-skips    add -m  "$(echo "$PTRESULTS" | grep SKIP)" HEAD
    git notes --ref=patchtest-results-passes    add -m "$(echo "$PTRESULTS" | grep PASS)" HEAD
    git notes --ref=patchtest-log add -m "$PTLOG" HEAD
}

function testpatch() {
    local patch="$1"

    # get current branch
    CURRENTB="$(cd $repodir; git rev-parse --abbrev-ref HEAD)"

    # create assemblebrach if it does not exist
    if [ -n "$assemblebranch" ]; then
	test "$assemblebranch" = "$CURRENTB" && { echo "The assemble branch must be different that current one"; exit 1; }
	( cd $repodir
	  git show-ref --verify --quiet refs/heads/$assemblebranch || \
	      { git branch $assemblebranch $startpoint; }
	)
    fi

    echo -e "${patch}"

    tmp="$(mktemp)"
    # run patchtest
    PTRESULTS="$(patchtest $patch --repo-dir $repodir --start-dir $startdir 2>$tmp)"
    PTLOG="$(cat $tmp)"
    rm $tmp

    if [ -n "$outrepodir" ]; then
	patchfn=$(basename $patch)

	# just create a commit if patch is not tracked yet
	test ! -f $patchfn && {
	    cp $patch $outrepodir/$patchfn

	    # go to the output repo and create a commit with git-notes
	    ( cd $outrepodir
	      git add $patchfn
	      git commit -s -m "$patch"
	      gitnotes
	    )
	    echo -e "\tResults stored into '$outrepodir'";
	} || { echo -e "\tAlready tested"; }
    fi

    if [ -n "$assemblebranch" ]; then
	# if assemble branch give, try to assemble as many as possible

	(
	    cd $repodir

	    # move the assemblebranch, already created above
	    git checkout $assemblebranch --quiet

	    # try patch merge
	    if git apply --check $patch 2> /dev/null; then
		if [ -n "$mergeall" ]; then
		    git am --quiet $patch 2>/dev/null && gitnotes
		    echo -e "\tPatch merged into '${assemblebranch}' including all test results"
		else
		    if echo "$PTRESULTS" | grep FAIL; then
			echo -e "\tPatch has test failures, skipping"
		    else
			git am --quiet $patch 2>/dev/null && gitnotes
			echo -e "\tPatch merged into '${assemblebranch}' with no test failures"
		    fi
		fi
	    else
		echo -e "\tNot merged due to a merge-conflict"
	    fi

	    git checkout $CURRENTB --quiet
	)
    fi

    # just print the results either when verbose or when no outrepodir/assemblebranch given
    if [ -n "$verbose"  -o -z "$outrepodir" -a -z "$assemblebranch" ]; then
	echo -e "$PTLOG"
	echo -e "$PTRESULTS"
    fi

    echo -e ""
}

while getopts ":r:s:p:a:o:vAh" opt; do
    case $opt in
	r)
	    repodir=$OPTARG
	    ;;
	s)
	    startdir=$OPTARG
	    ;;
	p)
	    startpoint=$OPTARG
	    ;;
	a)
	    assemblebranch=$OPTARG
	    ;;
	o)
	    outrepodir=$OPTARG
	    ;;
	v)
	    verbose='x'
	    ;;
	A)
	    mergeall='x'
	    ;;
	h)
	    usage
	    ;;
	\?)
	    echo "Invalid option: -$OPTARG" >&2
	    usage
	    ;;
	:)
	    echo "Option -$OPTARG requires an argument." >&2
	    usage
	    ;;
    esac
done
shift $((OPTIND-1))

# Checks
test -z "$@" && { echo -e "Provide at least a patch or a patch directory"; usage; }
test -z "$repodir"  && { echo "Indicate the repository"; usage; }
test ! -d $repodir  && { echo "Repository does not exit"; usage; }
test ! -d $startdir && { echo "Test suite starting directory does not exist"; usage; }

# if outrepodir does not exit, create it
# if outrepodir is not a repository, create a new one
test -n "$outrepodir" && { test ! -d "$outrepodir" && { mkdir -p "$outrepodir"; }; }
test -n "$outrepodir" && { test ! -d "$outrepodir/.git" && { (cd "$outrepodir";  git init) }; }

for item in "$@"; do
    # if item is a directory, get all files and test each
    if [ -d $item ]; then
	for patch in $(find $item -type f -print0 | xargs -r0 stat -c %y\ %n | sort | cut -d' ' -f4); do
	    testpatch $patch
	done
    else
	testpatch $item
    fi
done
